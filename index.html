<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Delayed Executor — Monad Testnet</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

    :root {
        --neon: #0ff;
        --accent: #7b5cff;
        --bg: #06121a;
        --darker-bg: #02060a;
        --danger: #ff5577;
        --gold: #FFD700;
    }

    .app {
        background-color: var(--bg);
        color: var(--neon);
        font-family: 'Inter', sans-serif;
        margin: 0;
        padding: 30px;
        max-width: 900px;
        margin: 0 auto;
    }

    .container {
        max-width: 600px;
        margin: 0 auto;
    }

    .app h1 {
        text-align: center;
        font-family: 'Press Start 2P', cursive;
        font-size: 1.2rem;
        color: var(--neon);
        text-shadow: 0 0 5px var(--neon), 0 0 10px rgba(0, 255, 255, 0.5);
        margin-bottom: 30px;
    }

    .app h2 {
        font-family: 'Press Start 2P', cursive;
        font-size: 0.9rem;
        color: var(--neon);
        text-shadow: 0 0 5px var(--neon), 0 0 10px rgba(0, 255, 255, 0.5);
        margin-bottom: 15px;
    }

    .app p { margin: 10px 0; font-size: 0.9rem; }
    
    .card {
        background: linear-gradient(180deg, rgba(6,16,22,0.96), rgba(2,6,10,0.96));
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        border: 1px solid rgba(123, 92, 255, 0.5);
        box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    #walletSection { display: none; }

    .ui {
        background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.06));
        border: 1px solid rgba(123, 92, 255, 0.3);
        color: var(--neon);
        padding: 12px 15px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        backdrop-filter: blur(4px);
        transition: all 0.2s ease;
        font-size: 0.9rem;
        font-family: 'Inter', sans-serif;
        width: 100%;
        margin-top: 8px;
        box-sizing: border-box;
    }
    .ui:hover, .ui:focus {
        border-color: rgba(0, 255, 255, 0.7);
        background: rgba(0, 255, 255, 0.1);
        box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
        outline: none;
    }
    .ui:disabled { 
        cursor: not-allowed; 
        opacity: 0.5; 
        background: rgba(0,0,0,0.2); 
        border-color: rgba(123, 92, 255, 0.2); 
    }
    .ui.danger { border-color: var(--danger); color: var(--danger); }
    .ui.danger:hover { border-color: var(--danger); background: rgba(255, 85, 119, 0.1); box-shadow: 0 0 8px rgba(255, 85, 119, 0.3); }
    
    input.ui, textarea.ui, select.ui { width: 100%; box-sizing: border-box; }
    textarea.ui { resize: vertical; }

    select.ui option {
        background-color: var(--darker-bg);
        color: var(--neon);
    }
    
    #messageControls { display: flex; gap: 10px; }
    #messageInput { flex-grow: 1; }
    
    #chat {
        height: 350px;
        overflow-y: scroll;
        background: var(--darker-bg);
        border: 1px solid rgba(123, 92, 255, 0.5);
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }
    
    #chat::-webkit-scrollbar { width: 8px; }
    #chat::-webkit-scrollbar-track { background: transparent; }
    #chat::-webkit-scrollbar-thumb { background-color: var(--accent); border-radius: 10px; border: 2px solid var(--darker-bg); }

    .message {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        max-width: 85%;
        align-self: flex-start;
    }
    .message-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 2px solid var(--accent);
        flex-shrink: 0;
    }
    .message-content {
        display: flex;
        flex-direction: column;
        background: rgba(123, 92, 255, 0.1);
        padding: 8px 12px;
        border-radius: 10px;
        word-wrap: break-word;
    }
    .message-from { font-weight: bold; }
    .message-text { margin-top: 4px; color: #eee; }
    .message-time { font-size: 0.7rem; opacity: 0.6; align-self: flex-end; margin-top: 5px; }

    .your-message {
        align-self: flex-end;
        flex-direction: row-reverse;
    }
    .your-message .message-avatar { border-color: var(--neon); }
    .your-message .message-content { background: rgba(0, 255, 255, 0.15); }
    
    .balance { font-weight: bold; color: var(--gold); text-shadow: 0 0 4px var(--gold); }
    
    /* --- Styles for avatar and color picker --- */
    .picker-container { display: flex; flex-wrap: wrap; gap: 10px; }
    .picker-label { width: 100%; margin-bottom: 5px; font-weight: bold; }
    
    .avatar-option {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid transparent;
        transition: border-color 0.2s;
    }
    .avatar-option.selected { border-color: var(--neon); }

    .color-option {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        border: 3px solid rgba(255,255,255,0.2);
        transition: transform 0.2s;
    }
    .color-option.selected { border-color: var(--neon); transform: scale(1.1); }

    /* NFT Animated Frame */
    @keyframes nft-glow {
        0% { 
            box-shadow: 0 0 5px var(--neon), 0 0 10px var(--neon), 0 0 15px var(--neon); 
            border-color: var(--neon);
        }
        50% { 
            box-shadow: 0 0 20px var(--neon), 0 0 30px var(--neon), 0 0 40px var(--neon); 
            border-color: var(--gold);
        }
        100% { 
            box-shadow: 0 0 5px var(--neon), 0 0 10px var(--neon), 0 0 15px var(--neon); 
            border-color: var(--neon);
        }
    }
    .nft-avatar {
        animation: nft-glow 2s ease-in-out infinite;
        border-width: 3px !important;
    }

    /* Loading and error states */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--neon);
        animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    .error { color: var(--danger); font-size: 0.8rem; margin-top: 5px; }
    .success { color: #51cf66; }

    label {
        font-size: 13px;
        color: var(--accent);
        font-weight: 600;
    }

    .order-item { 
        background: rgba(123, 92, 255, 0.1); 
        border: 1px solid rgba(123, 92, 255, 0.5); 
        padding: 15px; 
        border-radius: 10px; 
        margin: 10px 0; 
        position: relative; 
    }
    .order-item.pending { 
        border-left: 4px solid #4caf50; 
        background: rgba(76,175,80,0.1); 
    }
    .order-item.executed { 
        opacity: 0.6; 
        border-left: 4px solid #ff9800; 
    }
    .order-item.ready { 
        border-left-color: #00e676 !important; 
        box-shadow: 0 0 10px rgba(0, 230, 118, 0.5); 
    }
    .order-item code { 
        word-break: break-all; 
        font-size: 11px; 
        background: var(--darker-bg); 
        padding: 4px; 
        border-radius: 4px; 
        color: var(--neon); 
    }
    .order-item b { 
        color: var(--gold); 
        text-shadow: 0 0 4px var(--gold); 
    }

    button.mini-execute { 
        width: auto; 
        padding: 8px 16px; 
        margin-left: 10px; 
        font-size: 12px; 
        background: linear-gradient(135deg, var(--neon), var(--accent)); 
        border: 1px solid var(--neon); 
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 1px 0 rgba(255,255,255,0.2); 
        color: var(--darker-bg);
        font-weight: bold;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    button.mini-execute:hover { 
        box-shadow: 0 0 20px var(--neon), 0 0 30px var(--accent);
        transform: translateY(-2px);
        background: linear-gradient(135deg, var(--accent), var(--neon));
    }
    button.mini-execute:active {
        transform: translateY(0);
    }

    .muted { 
        color: rgba(0, 255, 255, 0.6); 
        font-size: 13px; 
    }

    a { 
        color: var(--accent); 
        text-decoration: none; 
    }
    a:hover { 
        text-shadow: 0 0 5px var(--accent); 
    }

    /* Delay inputs row */
    .delay-row {
        display: flex;
        gap: 10px;
    }
    .delay-row input {
        flex: 1;
    }

    /* Checkbox and datetime picker */
    #dateTimePicker {
        margin-top: 10px;
    }
    #useDateTimeCheckbox {
        margin-left: 8px;
        transform: scale(1.2);
        accent-color: var(--neon);
    }

    /* Enhanced Execute button in executeCard */
    #executeBtn {
        background: linear-gradient(135deg, var(--neon), var(--accent)); 
        border: 1px solid var(--neon); 
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3), inset 0 1px 0 rgba(255,255,255,0.2); 
        color: var(--darker-bg);
        font-weight: bold;
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding: 12px 20px;
        font-size: 1rem;
    }
    #executeBtn:hover {
        box-shadow: 0 0 20px var(--neon), 0 0 30px var(--accent);
        transform: translateY(-2px);
        background: linear-gradient(135deg, var(--accent), var(--neon));
    }
    #executeBtn:active {
        transform: translateY(0);
    }

    /* Filter row */
    .filter-row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
    }
    .filter-row label {
        min-width: 120px;
    }
    .filter-row select, .filter-row input {
        flex: 1;
        min-width: 100px;
    }

    /* Show more button */
    #showMoreBtn {
        width: auto;
        align-self: center;
        margin: 20px auto;
    }

    /* Responsive improvements */
    @media (max-width: 480px) {
        .app { padding: 0px; }
        .container { max-width: 100%; }
        .app h1 { font-size: 1rem; }
        #messageControls { flex-direction: column; }
        .delay-row { flex-direction: column; }
        .filter-row { flex-direction: column; }
        .filter-row label { min-width: auto; }
    }

    pre {
        background: var(--darker-bg); 
        padding: 8px; 
        border-radius: 8px; 
        overflow: auto; 
        font-size: 13px; 
        border: 1px solid rgba(123, 92, 255, 0.5); 
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Delayed Executor — Monad Testnet</h1>

    <div class="card">
      <button id="connectBtn" class="ui">🦊 Connect MetaMask</button>
      <p id="status">Not connected</p>
    </div>

    <div class="card" id="createCard" style="display:none;">
      <h2>Create Delayed Order</h2>

      <label>Order Type</label>
      <select id="orderType" class="ui">
        <option value="native">Send MON (native)</option>
        <option value="erc20">ERC20.transfer()</option>
        <option value="custom">Custom calldata</option>
      </select>

      <div id="nativeFields">
        <label>Target (where to send MON)</label>
        <input id="targetNative" class="ui" placeholder="0x..."/>
        <label>Amount (MON)</label>
        <input id="valueNative" class="ui" type="number" step="0.000000000000000001" value="0.01"/>
      </div>

      <div id="erc20Fields" style="display:none;">
        <label>ERC20 Token Address</label>
        <input id="erc20Address" class="ui" placeholder="0x..."/>
        <label>Recipient (to)</label>
        <input id="erc20To" class="ui" placeholder="0x..."/>
        <label>Token Amount</label>
        <input id="erc20Amount" class="ui" type="number" step="0.000000000000000001" value="0"/>
      </div>

      <div id="customFields" style="display:none;">
        <label>Target</label>
        <input id="targetCustom" class="ui" placeholder="0x..."/>
        <label>Calldata (hex)</label>
        <textarea id="dataCustom" class="ui" placeholder="0x..."></textarea>
        <label>Value (MON)</label>
        <input id="valueCustom" class="ui" type="number" step="0.000000000000000001" value="0"/>
      </div>

      <label>Delay</label>
      <div class="delay-row">
        <input id="delayDays" class="ui" type="number" min="0" value="0" placeholder="Days"/>
        <input id="delayHours" class="ui" type="number" min="0" max="23" value="0" placeholder="Hours"/>
        <input id="delayMinutes" class="ui" type="number" min="0" max="59" value="1" placeholder="Minutes"/>
      </div>

      <label style="display: flex; align-items: center;">
        <input type="checkbox" id="useDateTimeCheckbox"> Select date and time
      </label>
      <div id="dateTimePicker" style="display:none;">
        <input type="datetime-local" id="executeDateTime" class="ui" />
      </div>

      <button id="createOrderBtn" class="ui">Create Order</button>
      <p id="createResult"></p>
    </div>

    <div class="card" id="ordersCard" style="display:none;">
      <h2>View Orders</h2>
      <div class="filter-row">
        <label>Load up to ID (max 1000):</label>
        <input id="readMax" class="ui" type="number" value="100" min="1" max="1000"/>
        <label>Filter:</label>
        <select id="filterOrders" class="ui">
          <option value="all">All</option>
          <option value="waiting">Waiting</option>
          <option value="ready">Ready to Execute</option>
          <option value="executed">Executed</option>
        </select>
      </div>
      <button id="readOrdersBtn" class="ui">Load</button>
      <p class="muted">Auto-refresh every 10 sec. Orders sorted by execution time (newest first).</p>
      <div id="ordersList"></div>
      <button id="showMoreBtn" class="ui" style="display:none;">Show More</button>
      <p id="paginationInfo" class="muted"></p>
    </div>

    <div class="card" id="executeCard" style="display:none;">
      <h2>Execute Order (manual)</h2>
      <label>Order ID</label>
      <input id="execId" class="ui" placeholder="e.g. 1"/>
      <button id="executeBtn" class="ui">Execute(id)</button>
      <p id="execResult"></p>
      <p id="execTimeInfo" class="muted"></p>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
  <script>
    (async function(){
      const { ethers } = window;
      const CONTRACT_ADDRESS = "0x158290dA77268EE28bc16F7d3D6Dbf10C866e791";
      const ERC20_ABI = ["function decimals() view returns (uint8)"];
      const ABI = [
        "event OrderCreated(uint256 id, address target, bytes data, uint256 executeAfter)",
        "event OrderExecuted(uint256 id, address executor, bool success, bytes returnData)",
        "function createOrder(address target, bytes data, uint256 executeAfter) payable returns (uint256)",
        "function execute(uint256 id)",
        "function orders(uint256) view returns (address creator,address target,uint256 value,bytes data,uint256 executeAfter,bool executed)"
      ];

      const MONAD_PARAMS = {
        chainId: '0x279f',
        chainName: 'Monad Testnet',
        nativeCurrency: { name: 'MON', symbol: 'MON', decimals: 18 },
        rpcUrls: ['https://testnet-rpc.monad.xyz'],
        blockExplorerUrls: ['https://testnet.monadexplorer.com']
      };

      let provider, signer, contract, wsProvider, contractWs, autoRefreshInterval;
      let allOrders = [];
      let shownOrders = [];
      let currentOffset = 0;
      const pageSize = 10;

      const connectBtn = document.getElementById("connectBtn");
      const status = document.getElementById("status");
      const createCard = document.getElementById("createCard");
      const ordersCard = document.getElementById("ordersCard");
      const executeCard = document.getElementById("executeCard");
      const orderType = document.getElementById("orderType");
      const execIdInput = document.getElementById("execId");
      const executeBtn = document.getElementById("executeBtn");
      const execResult = document.getElementById("execResult");
      const execTimeInfo = document.getElementById("execTimeInfo");
      const readOrdersBtn = document.getElementById("readOrdersBtn");
      const ordersList = document.getElementById("ordersList");
      const filterOrders = document.getElementById("filterOrders");
      const showMoreBtn = document.getElementById("showMoreBtn");
      const paginationInfo = document.getElementById("paginationInfo");

      const nativeFields = document.getElementById("nativeFields");
      const erc20Fields = document.getElementById("erc20Fields");
      const customFields = document.getElementById("customFields");
      const useDateTimeCheckbox = document.getElementById("useDateTimeCheckbox");
      const dateTimePicker = document.getElementById("dateTimePicker");
      const delayDays = document.getElementById("delayDays");
      const delayHours = document.getElementById("delayHours");
      const delayMinutes = document.getElementById("delayMinutes");
      const executeDateTime = document.getElementById("executeDateTime");

      orderType.addEventListener("change", () => {
        nativeFields.style.display = orderType.value === "native" ? "block" : "none";
        erc20Fields.style.display = orderType.value === "erc20" ? "block" : "none";
        customFields.style.display = orderType.value === "custom" ? "block" : "none";
      });

      useDateTimeCheckbox.addEventListener("change", () => {
        dateTimePicker.style.display = useDateTimeCheckbox.checked ? "block" : "none";
        if (useDateTimeCheckbox.checked) {
          const now = new Date();
          now.setMinutes(now.getMinutes() + 1);
          executeDateTime.value = now.toISOString().slice(0, 16);
        }
      });

      filterOrders.addEventListener("change", () => {
        allOrders = []; // Reset to re-filter
        shownOrders = [];
        currentOffset = 0;
        loadAndDisplayOrders();
      });

      showMoreBtn.addEventListener("click", () => {
        currentOffset += pageSize;
        loadAndDisplayOrders();
      });

      function formatWaitingTime(waitSec) {
        let totalSec = waitSec;
        const days = Math.floor(totalSec / 86400);
        totalSec %= 86400;
        const hours = Math.floor(totalSec / 3600);
        totalSec %= 3600;
        const minutes = Math.floor(totalSec / 60);
        const seconds = totalSec % 60;
        let parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0) parts.push(`${minutes}m`);
        if (seconds > 0 || parts.length === 0) parts.push(`${seconds}s`);
        return parts.join(' ');
      }

      async function loadAndDisplayOrders() {
        if (!contract) return;
        try {
          let maxId = parseInt(document.getElementById("readMax").value || "100");
          maxId = Math.min(maxId, 1000);
          const currentTime = Math.floor(Date.now() / 1000);
          let newOrders = [];
          for (let id = 1; id <= maxId; id++) {
            try {
              const o = await contract.orders(BigInt(id));
              if (o.creator === ethers.ZeroAddress) continue;
              const dt = new Date(Number(o.executeAfter) * 1000).toLocaleString();
              newOrders.push({
                id,
                creator: o.creator,
                target: o.target,
                value: ethers.formatEther(o.value),
                executeAfter: Number(o.executeAfter),
                executed: o.executed,
                data: o.data,
                dt
              });
            } catch (e) {
              // Silently skip non-existent orders (CALL_EXCEPTION or similar)
              if (e.code === 'CALL_EXCEPTION') {
                console.log(`Order ${id} does not exist, skipping.`);
              } else {
                console.error(`Error loading order ${id}:`, e);
              }
              continue;
            }
          }
          allOrders = newOrders.sort((a, b) => b.executeAfter - a.executeAfter); // Descending: newest first

          displayOrders(currentTime);
        } catch(e) {
          console.error('Unexpected error in loadAndDisplayOrders:', e);
          ordersList.innerHTML = `<span class="error">Unexpected error loading orders. Please try again.</span>`;
        }
      }

      function displayOrders(currentTime) {
        const filter = filterOrders.value;

        let filtered = allOrders.map(order => ({
          ...order,
          isReady: !order.executed && currentTime >= order.executeAfter,
          isWaiting: !order.executed && currentTime < order.executeAfter
        })).filter(order => {
          if (filter === "all") return true;
          if (filter === "waiting") return order.isWaiting;
          if (filter === "ready") return order.isReady;
          if (filter === "executed") return order.executed;
          return false;
        });

        // Already sorted descending from load

        const start = currentOffset;
        const end = start + pageSize;
        const pageOrders = filtered.slice(start, end);

        let html = "";
        pageOrders.forEach(order => {
          const className = `order-item ${order.executed ? 'executed' : (order.isReady ? 'ready' : 'pending')}`;
          let execBtn = "";
          if (order.isReady) {
            execBtn = `<button class="mini-execute" onclick="executeOrder(${order.id})">Execute</button>`;
          } else if (order.isWaiting) {
            const waitSec = order.executeAfter - currentTime;
            execBtn = `<span class="muted">Waiting: ${formatWaitingTime(waitSec)}</span>`;
          } else {
            execBtn = `<span class="muted">Executed</span>`;
          }
          html += `<div class="${className}">
            <b>ID ${order.id}</b> ${execBtn}<br>
            creator: ${order.creator}<br>
            target: ${order.target}<br>
            value: ${order.value} MON<br>
            executeAfter: ${order.dt}<br>
            data: <code>${order.data}</code>
          </div>`;
        });

        if (currentOffset === 0) {
          ordersList.innerHTML = html;
        } else {
          ordersList.innerHTML += html;
        }

        const totalFiltered = filtered.length;
        const totalShown = Math.min(end, totalFiltered);
        paginationInfo.textContent = `Showing ${totalShown} of ${totalFiltered} orders`;

        showMoreBtn.style.display = totalShown < totalFiltered ? 'block' : 'none';
      }

      async function updateExecTimeInfo() {
        const idStr = execIdInput.value.trim();
        if (!idStr || !contract) {
          execTimeInfo.textContent = "";
          executeBtn.disabled = false;
          return;
        }
        try {
          const id = BigInt(idStr);
          const o = await contract.orders(id);
          if (o.creator === ethers.ZeroAddress) {
            execTimeInfo.textContent = "Order not found.";
            executeBtn.disabled = true;
            return;
          }
          if (o.executed) {
            execTimeInfo.textContent = "Order already executed.";
            executeBtn.disabled = true;
            return;
          }
          const currentTime = Math.floor(Date.now() / 1000);
          const executeAfter = Number(o.executeAfter);
          const dt = new Date(executeAfter * 1000).toLocaleString();
          if (currentTime < executeAfter) {
            const waitSec = executeAfter - currentTime;
            execTimeInfo.innerHTML = `<span class="error">Too early! Wait ${formatWaitingTime(waitSec)} until ${dt}</span>`;
            executeBtn.disabled = true;
          } else {
            execTimeInfo.textContent = `Ready to execute (from ${dt})`;
            executeBtn.disabled = false;
          }
        } catch (e) {
          if (e.code === 'CALL_EXCEPTION') {
            execTimeInfo.textContent = "Order not found.";
            executeBtn.disabled = true;
          } else {
            execTimeInfo.textContent = "Check error: " + e.message;
            executeBtn.disabled = true;
          }
        }
      }

      execIdInput.addEventListener("input", updateExecTimeInfo);

      async function executeOrder(id) {
        try {
          const idStr = id.toString();
          const o = await contract.orders(id);
          const currentTime = Math.floor(Date.now() / 1000);
          if (currentTime < Number(o.executeAfter)) {
            throw new Error(`Too early! Wait until ${new Date(Number(o.executeAfter) * 1000).toLocaleString()}`);
          }
          if (o.executed) throw new Error("Order already executed");
          const tx = await contract.execute(id);
          execResult.innerHTML = `<span class="success">Tx: <a href="https://testnet.monadexplorer.com/tx/${tx.hash}" target="_blank">${tx.hash}</a> — waiting...</span>`;
          await tx.wait();
          execResult.innerHTML = `<span class="success">✅ Executed! Tx: <a href="https://testnet.monadexplorer.com/tx/${tx.hash}" target="_blank">${tx.hash}</a></span>`;
          updateExecTimeInfo();
          allOrders = []; // Refresh
          shownOrders = [];
          currentOffset = 0;
          loadAndDisplayOrders();
        } catch(e) {
          execResult.innerHTML = `<span class="error">Error: ${e.message}</span>`;
        }
      }

      readOrdersBtn.addEventListener("click", () => {
        allOrders = [];
        shownOrders = [];
        currentOffset = 0;
        loadAndDisplayOrders();
      });

      async function switchToMonad() {
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: MONAD_PARAMS.chainId }] });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [MONAD_PARAMS] });
          } else {
            throw switchError;
          }
        }
      }

      connectBtn.addEventListener("click", async ()=>{
        if(!window.ethereum) return alert("Install MetaMask");

        await switchToMonad();
        provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();

        const addr = await signer.getAddress();
        const net = await provider.getNetwork();

        if (net.chainId !== 10143n) {
          alert("Please switch to Monad Testnet");
          return;
        }

        status.textContent = `✅ Connected: ${addr} (Monad Testnet)`;
        createCard.style.display = ordersCard.style.display = executeCard.style.display = "block";
        contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

        wsProvider = new ethers.WebSocketProvider('wss://testnet-rpc.monad.xyz');
        contractWs = new ethers.Contract(CONTRACT_ADDRESS, ABI, wsProvider);

        setupEventListeners();

        autoRefreshInterval = setInterval(() => {
          allOrders = [];
          loadAndDisplayOrders();
        }, 10000); // Reduced to 10 seconds for more real-time feel without overload
        loadAndDisplayOrders();
      });

      document.getElementById("createOrderBtn").addEventListener("click", async ()=>{
        try {
          let executeAfter;
          if (useDateTimeCheckbox.checked) {
            const dtValue = document.getElementById("executeDateTime").value;
            if (!dtValue) throw new Error("Please select a date and time");
            executeAfter = Math.floor(new Date(dtValue).getTime() / 1000);
            if (executeAfter <= Math.floor(Date.now() / 1000)) throw new Error("Execution time must be in the future");
          } else {
            const days = parseInt(delayDays.value || "0");
            const hours = parseInt(delayHours.value || "0");
            const minutes = parseInt(delayMinutes.value || "1");
            if (days < 0 || hours < 0 || minutes < 0) throw new Error("Delay values must be non-negative");
            const delaySec = days * 86400 + hours * 3600 + minutes * 60;
            executeAfter = Math.floor(Date.now() / 1000) + delaySec;
            if (delaySec <= 0) throw new Error("Delay must be at least 1 minute");
          }

          let target, data, valueWei;

          if(orderType.value === "native"){
            target = document.getElementById("targetNative").value.trim();
            if (!ethers.isAddress(target)) throw new Error("Invalid target address");
            const valMON = document.getElementById("valueNative").value.trim() || "0";
            valueWei = ethers.parseEther(valMON);
            data = "0x";
          }
          else if(orderType.value === "erc20"){
            const token = document.getElementById("erc20Address").value.trim();
            const to = document.getElementById("erc20To").value.trim();
            const amt = document.getElementById("erc20Amount").value.trim();
            if(!ethers.isAddress(token) || !ethers.isAddress(to)) throw new Error("Invalid address");
            if (!amt || parseFloat(amt) <= 0) throw new Error("Token amount must be > 0");
            const tokenContract = new ethers.Contract(token, ERC20_ABI, provider);
            const decimals = await tokenContract.decimals();
            const iface = new ethers.Interface(["function transfer(address,uint256)"]);
            data = iface.encodeFunctionData("transfer",[to, ethers.parseUnits(amt, decimals)]);
            target = token;
            valueWei = 0n;
          } else {
            target = document.getElementById("targetCustom").value.trim();
            if (!ethers.isAddress(target)) throw new Error("Invalid target address");
            data = document.getElementById("dataCustom").value.trim();
            if (!data.startsWith("0x")) throw new Error("Calldata must start with 0x");
            const valMON = document.getElementById("valueCustom").value.trim() || "0";
            valueWei = ethers.parseEther(valMON);
          }

          const tx = await contract.createOrder(target, data, executeAfter, { value: valueWei });
          document.getElementById("createResult").innerHTML = `<span class="success">⏳ Tx sent: <a href="https://testnet.monadexplorer.com/tx/${tx.hash}" target="_blank">${tx.hash}</a></span>`;
          await tx.wait();
          document.getElementById("createResult").innerHTML = `<span class="success">✅ Order created: <a href="https://testnet.monadexplorer.com/tx/${tx.hash}" target="_blank">${tx.hash}</a></span>`;
          allOrders = []; // Refresh
          loadAndDisplayOrders();
        } catch(e) {
          let errorMsg = e.message;
          // Handle user rejection more gracefully
          if (e.code === 'ACTION_REJECTED' || e.code === 4001 || e.message.includes('user rejected') || e.message.includes('User denied transaction signature')) {
            errorMsg = 'Transaction rejected by user. Please confirm the signature in MetaMask to create the order.';
          }
          document.getElementById("createResult").innerHTML = `<span class="error">Error: ${errorMsg}</span>`;
        }
      });

      executeBtn.addEventListener("click", async ()=>{
        const idStr = execIdInput.value.trim();
        if (!idStr) throw new Error("Enter order ID");
        await executeOrder(BigInt(idStr));
      });

      function appendOrderEvent(type, id) {
        const div = document.createElement('div');
        div.style.border = "1px solid #4466aa";
        div.style.padding = "8px";
        div.style.borderRadius = "8px";
        div.style.margin = "6px 0";
        div.innerHTML = `<span class="success">[${new Date().toLocaleTimeString()}] ${type}: ID ${id}</span>`;
        ordersList.prepend(div);
        allOrders = []; // Refresh
        loadAndDisplayOrders();
      }

      function setupEventListeners() {
        if (!contractWs) return;
        contractWs.on('OrderCreated', (id, target, data, executeAfter) => {
          console.log(`OrderCreated: ID ${id}`);
          appendOrderEvent("Order Created", id);
        });

        contractWs.on('OrderExecuted', (id, executor, success, returnData) => {
          console.log(`OrderExecuted: ID ${id}, success: ${success}`);
          appendOrderEvent(`Order Executed (${success ? "successfully" : "with error"})`, id);
        });
      }

      window.executeOrder = executeOrder;
    })();
  </script>
</body>
</html>
